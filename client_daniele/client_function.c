#include "client_hdr.h"

/* readkey from file -  Read a key from a file whose name is passed in fk and store it to key */
int readKey (unsigned char * key, int maxlength, const char * fk) {
    
	int keylength = 0;
	char* file_name_key = malloc(strlen(PATH_FOR_KEY) + strlen(fk) + 1);
    	strcpy(file_name_key, PATH_FOR_KEY);
    	strcpy(file_name_key + strlen(PATH_FOR_KEY), fk);
    	FILE * keyf;
    
    	if ((keyf = fopen(file_name_key, "r")) == NULL)
        	return -1;
    
    	keylength = fread(key, sizeof(char), maxlength, keyf);
    
    	fclose(keyf);
   	return keylength;
}

/* start_protocol function - It starts the protocol to set the session key and returns -1 if errors occur*/
int start_protocol(int sk, unsigned char** session_key, int * session_key_len, char*argv[]){

    	int ret;                                        			/* function returns */
    	int msg_size;                                   		/* lenght of sent messages*/
    	int usr_name_len, server_name_len;             	/* len. of name of client,len. of server name*/
    	int enc_buf_len_1,enc_buf_len_2;               	/* len of encrypt buffer 1 and 2*/
    	int enc_buf_len;                               	 	/* len of encrypt buffer */
    
    	unsigned char *new_Nb;                        	  	/* var for Nb compute by client */
    	unsigned char *enc_buf;                         	/* enc. buffer*/
    	unsigned char *enc_buf_tmp_1, *enc_buf_tmp_2;   	/* enc. buffer*/
    	unsigned char *plain_text_1, *plain_text_2;     		/* plain text */
    	unsigned char *secret_key;                      	/* buffer for secret key: Kab */
    	unsigned char *msg;                             		/* sent message*/
    	unsigned char *Na, *Nb;                         	/* buffer for nonces */
    
    	EVP_CIPHER_CTX  * ctx;                          	/* Context ctx: for long term key: Kab */
    	int bsize;                                      			/* var for ctx */
    	int loutU, loutF;
    
    	EVP_CIPHER_CTX  * session_ctx;                  	/* Context session_ctx: for decrypt with session key (Kab') */
    	EVP_CIPHER_CTX  * session_ctx_encrypt;     	/* Context session_ctx: for encypt with session key (Kab') */
    	int session_bsize;                              		/* var for session_ctx and session_ctx_encypt */
    	int session_loutU, session_loutF;
    
    	secret_key = malloc(KEY_SIZE);
    	/* Retrieve key */
    	if( readKey(secret_key, KEY_SIZE, argv[3]) < 0 ){
        	printf("Enable to read long term key.\n");
        	return -1;
     	}
     
     	/*  Protocol
        M1: A --> B A, B, Na
        A: nome utente (argv[3])
        B: nome server (nel nostro caso IP) (argv[1])
        Na: Nonce <-- RAND_bytes() lungo 4 byte; */ 
    
    	printf("Start protocol for establishing session key\n");
    
    	/* creating A's nonce */
    	Na = malloc(sizeof(int));			
    	RAND_bytes(Na, sizeof(int));
    
    	usr_name_len = strlen(argv[3]);
    	server_name_len = strlen(argv[1]);
    
    	/* NOTE: WE won't use eof char */
    	msg_size = usr_name_len + sizeof(int) + server_name_len;			
    	msg = malloc(msg_size);

    	/* strcat gives some problems */
    	memcpy(msg, argv[3], usr_name_len);
    	memcpy(msg + usr_name_len , argv[1], server_name_len);
    	memcpy(msg + usr_name_len + server_name_len, Na, sizeof(int));		
    
    	/* Send message M1 */
    	ret = send(sk, &msg_size, sizeof(int), 0); 
	if(ret != sizeof(int)){
        	printf("Error trasmitting the length of the first protocol message\n ");
        	return -1;
	}

    	ret = send(sk, msg, msg_size, 0); 
	if(ret != msg_size){
        	printf("Error trasmitting the first protocol message\n ");
        	return -1;
	}
	
    	/* End message M1 */
    
    	/* Start message M2 */
     	
	/*	
       Waiting for M2
       M2: B --> A {B, Na, Kab'}Kab, {Nb}Kab'
       B: nome server
       Na: Nonce send by client
       Kab' = session key, generated by server
       Nb =  Nonce generated by server */     

    	/* recieve message length of the first part of M2 {B, Na, Kab'}Kab */
    	ret = recv(sk, &enc_buf_len_1, sizeof(int), MSG_WAITALL); 
    	if(ret != sizeof(int)) {
        	printf("Error receiving M2 size\n");
        	return -1;
    	}
    
    	/* recieve message length of the second part of M2 {Nb}Kab' */
    	ret = recv(sk, &enc_buf_len_2, sizeof(int), MSG_WAITALL);
    	if(ret != sizeof(int)) {
        	printf("Error receiving M2 size\n");
        	return -1;
    	}
    
    	enc_buf = malloc(enc_buf_len_1 + enc_buf_len_2 );	

    	/* Recieve message M2 */		
    	ret = recv(sk, enc_buf, enc_buf_len_1 + enc_buf_len_2, MSG_WAITALL);
    	if(ret != (enc_buf_len_1 + enc_buf_len_2)) {
        	printf("Error receiving M2\n");
        	return -1;
    	}
    
    
    	/* allocation context ctx for decrypt: {B, Na, Kab'}Kab */
    	ctx = malloc(sizeof(EVP_CIPHER_CTX));
    	EVP_CIPHER_CTX_init(ctx);
    	EVP_DecryptInit(ctx, EVP_des_ecb(), NULL, NULL);
    	EVP_DecryptInit(ctx, NULL, secret_key, NULL);
    	EVP_CIPHER_CTX_set_key_length(ctx, KEY_SIZE);
    	bsize = EVP_CIPHER_CTX_block_size(ctx);
    
    	enc_buf_tmp_1 = malloc(enc_buf_len_1);
   	enc_buf_tmp_2 = malloc(enc_buf_len_2);

    	memcpy(enc_buf_tmp_1, enc_buf, enc_buf_len_1);
    	memcpy(enc_buf_tmp_2, enc_buf + enc_buf_len_1, enc_buf_len_2);

    	plain_text_1 = malloc(enc_buf_len_1 + bsize);
    
    
    	/* plain_text_1 has lenght of loutU+loutF and is equal: {B, Na, Kab'}Kab */
    	EVP_DecryptUpdate(ctx, plain_text_1, &loutU, enc_buf_tmp_1, enc_buf_len_1);
    	EVP_DecryptFinal(ctx, &plain_text_1[loutU], &loutF);
    
    	if (strncmp((const char*)plain_text_1, argv[1], server_name_len) != 0) {
        	printf("Error - the server is not the right one.\n");
        	return -1;
    	}
    
    	if (strncmp((const char*)plain_text_1 + server_name_len, (const char*)Na, sizeof(int)) != 0){
        	printf("Error - the server sent a different nonce.\n");
        	return -1;
    	}
    
    	/* session_key_len is calculated in this way because the message received is B, Na, Kab' 
       whose total lenght is loutU + loutF. Nab' is equal to sizeof(int) and the server name
       length is equal to server_name_len */ 
    	*session_key_len = loutU + loutF - server_name_len - sizeof(int);
    	*session_key = malloc(*session_key_len);
    	memcpy(*session_key, plain_text_1 + server_name_len + sizeof(int), *session_key_len);
    
    	/* Context session_ctx allocation for decrypt: {Nb}Kab' */
    	session_ctx = malloc(sizeof(EVP_CIPHER_CTX));
    	EVP_CIPHER_CTX_init(session_ctx);
    	EVP_DecryptInit(session_ctx, EVP_des_ecb(), NULL, NULL);
    	EVP_DecryptInit(session_ctx, NULL, (const unsigned char *) *session_key, NULL);
    	EVP_CIPHER_CTX_set_key_length(session_ctx, *session_key_len);
    	session_bsize = EVP_CIPHER_CTX_block_size(session_ctx);
    
    	plain_text_2 = malloc(enc_buf_len_2 + session_bsize);
    
    	EVP_DecryptUpdate(session_ctx, plain_text_2, &session_loutU, enc_buf_tmp_2, enc_buf_len_2);
    	EVP_DecryptFinal(session_ctx, &plain_text_2[session_loutU], &session_loutF);
    
   	Nb = malloc(session_loutU + session_loutF);			
    	memcpy(Nb, plain_text_2, session_loutU + session_loutF);
    
    	new_Nb = malloc(sizeof(int));
    	*Nb = (int)*Nb - 1;
    	memcpy(new_Nb, Nb, sizeof(int));
    
    	/* End message M2 */
    
    	/* Start message M3 */
    
	/*
     	send M3 to the server
    	M3: A --> B {Nb-1}Kab'
     	Nb: Nonce generato dal server  */    
    
    	/* Context session_ctx_encrypt allocation for encrypt: {Nb-1}Kab' */
    	session_ctx_encrypt = malloc(sizeof(EVP_CIPHER_CTX));
    	EVP_CIPHER_CTX_init(session_ctx_encrypt);
    	EVP_EncryptInit(session_ctx_encrypt, EVP_des_ecb(), NULL, NULL);
    	EVP_EncryptInit(session_ctx_encrypt, NULL, *session_key, NULL);
    	EVP_CIPHER_CTX_set_key_length(session_ctx_encrypt, *session_key_len);
    	session_bsize = EVP_CIPHER_CTX_block_size(session_ctx_encrypt);
    
    	free(enc_buf);
    	enc_buf = malloc(sizeof(int) + session_bsize);
    
    	EVP_EncryptUpdate(session_ctx_encrypt, enc_buf, &session_loutU, new_Nb, sizeof(int));
    	EVP_EncryptFinal(session_ctx_encrypt, &enc_buf[session_loutU], &session_loutF);
    	enc_buf_len = session_loutF + session_loutU;
    
    	ret = send(sk, &enc_buf_len , sizeof(int), 0); 
	if(ret != sizeof(int)){
        	printf("Error trasmitting size of encrypted Nb. Protocol terminated\n");
        	return -1;
	}
    
    	ret = send(sk, enc_buf , enc_buf_len, 0); 
	if(ret != enc_buf_len){
        	printf("Error trasmitting encrypted Nb. Protocol terminated\n");
        	return -1;
	}
	
    	/* End message M3 */
	
    	printf("End protocol for establishing session key, you are logged-in\n\n");

    	/* some clean up */
    	EVP_CIPHER_CTX_cleanup(ctx);
    	EVP_CIPHER_CTX_cleanup(session_ctx);
    	EVP_CIPHER_CTX_cleanup(session_ctx_encrypt);
    	free(ctx);
    	free(session_ctx);
    	free(session_ctx_encrypt);
    	free(secret_key);
    	free(Na);
    	free(msg);
    	free(enc_buf);
    	free(enc_buf_tmp_1);
    	free(enc_buf_tmp_2);
    	free(plain_text_1);
    	free(plain_text_2);
    	free(Nb);
    	free(new_Nb);

    	return 0;
}

/* This function sends a file to the server
	1) input file_name = name of the file to be sent
	2) input sk = socket used to send the file
 	3) returns 0 in case of success, -1 otherwise */
int send_file_crypt( const char* file_name, int sk, unsigned char* session_key, int session_key_len ) {
    
    	/* Allocation of the context each time we want send a message */
    	EVP_CIPHER_CTX *ctx = malloc(sizeof(EVP_CIPHER_CTX));
    	EVP_CIPHER_CTX_init(ctx);
    	EVP_EncryptInit(ctx, EVP_des_ecb(), NULL, NULL);
    	EVP_EncryptInit(ctx, NULL, session_key, NULL);
    	EVP_CIPHER_CTX_set_key_length(ctx, session_key_len);
    	int session_bsize = EVP_CIPHER_CTX_block_size(ctx);
    
    	FILE* file;			/* pointer to the file to be sent */
    	int name_size;		/* size of the name of the file to be sent */
    	int size; 			/* size of the file to be sent */
    	int ret; 			
    	unsigned char* buffer;	/* pointer to the buffer containing the file */
   	unsigned char* out;
    	char* path;
    	int loutU, loutF;   
    	struct stat informazioni;   
    	int out_len, err;
	
    	/* Computation of the length of the filename */
    	name_size = strlen(file_name) + 1;
    
    	/* changing directory */
   	path = malloc(strlen(path_usr_file) + strlen(file_name) + 1);
    	strcpy(path, path_usr_file);
    	strcat(path, file_name);

    	/* Open the file to be sent */
    	file = fopen(path,"rb");
    	if(file == NULL) {
        	printf("Error opening the file file\n");
        	return -1;
    	}
    
    	/* the send_message encrypts a message and send it to the server to let it understand what to do */
    	char* mex = "file";
    	err = send_message((unsigned char*)mex, sk, session_key, session_key_len);
    	if(err < 0 ){
		printf("It's not possible to communicate with the server\n");
		return -1;
    	}
    
    	/* Retrieve the size of the file to be sent */
    	stat(path, &informazioni);
    	size = informazioni.st_size; /* in byte */ 
    
    	/* Memory allocation for the file to be sent */
    	buffer = malloc(size);
    
    	/* File reading */
    	ret = fread(buffer, sizeof(char), size, file);
    	if(ret != size) {
        	printf("Error reading the file \n");
        	return -1;
    	}
    
    	fclose(file);
    
    	/* Only the content of the file is encrypted */
    
   	out = malloc(size + session_bsize);
    	if(out == NULL){
        	printf("No space available\n");
        	return -1;
    	}
    
    	EVP_EncryptUpdate(ctx, out, &loutU, buffer, size);
    	EVP_EncryptFinal(ctx, &out[loutU], &loutF);
    	out_len = loutU + loutF;						/* size of the encrypted file */ 
    
    	/* The length of the file name is sent */
    	ret = send(sk, &name_size, sizeof(int), 0); 
    	if(ret != sizeof(int)){
        	printf("Error transmitting the length of the file name\n ");
        	return -1;
    	}
    
    	/* The file name is sent */
    	ret = send(sk, file_name, name_size, 0); 
    	if(ret != name_size){
        	printf("Error transmitting the file name\n ");
        	return -1;
    	}
    
    	/* The file size is sent */
    	ret = send(sk, &out_len, sizeof(int), 0);
    	if(ret != sizeof(int)){
        	printf("Error transmitting the encrypt file size\n ");
        	return -1;
    	}
    
    	/* The file is sent */
    	ret = send(sk, out, out_len, 0);
    	if(ret != out_len){
        	printf("Error transmitting the encrypt file\n");
        	return -1;
    	}
    
    	printf("File %s with size %d bytes has been encrypt and sent\n", file_name, size);
    	EVP_CIPHER_CTX_cleanup(ctx);
    	free(ctx);
    	free(buffer);	
    	free(out);
    	free(path);
    
    	return 0;
}

/* ask_for_the_list - the client asks a list of file contained in the server */
int ask_for_the_list(int sk, unsigned char* session_key, int session_key_len){
	
	/* some variables */
	unsigned char* buffer;				/* for sending/receiving messages */
	unsigned char* enc_buffer;
	int loutU, loutF, size;
	int ret;
	
	/* allocating context for encrypting received list */
	EVP_CIPHER_CTX *ctx = malloc(sizeof(EVP_CIPHER_CTX));
	EVP_CIPHER_CTX_init(ctx);
	EVP_DecryptInit(ctx, EVP_des_ecb(), NULL, NULL);				
	EVP_DecryptInit(ctx, NULL, session_key, NULL);
	EVP_CIPHER_CTX_set_key_length(ctx, session_key_len);
	int session_bsize = EVP_CIPHER_CTX_block_size(ctx); 
	
	/* the send_message encrypts a message and send it to the server to let it understand what to do */
	char* mex = "list";
	ret = send_message((unsigned char*)mex, sk, session_key, session_key_len);
	if(ret < 0 ){
		printf("It's not possible to communicate with the server\n");
		return -1;
	}
	
	ret= recv(sk, &size, sizeof(int), MSG_WAITALL);  /* receiving length */
	if(ret != sizeof(int)){
	    printf("Error receiving the message.\n");
	    return -1;
	}
	
	/* allocating memory for encrypted message */
	enc_buffer = malloc(size);
	buffer = malloc(size + session_bsize);
	
	if(enc_buffer == NULL || buffer == NULL){
		printf("No memory available.\n");
		return -1;
	}
	
	ret = recv(sk, enc_buffer, size, MSG_WAITALL); 		/* receiving encrypted list of files */
	if(ret != size){
	  	printf("Error receiving the message.\n");
	  	return -1;
	}
	
	/* decrypting list and displaying it */ 
	EVP_DecryptUpdate(ctx, buffer, &loutU, enc_buffer, size);
	EVP_DecryptFinal(ctx, &buffer[loutU], &loutF);		/* file of free message	*/
	
	buffer[loutU + loutF] = '\0';
	printf("You currently have these files:\n%s", buffer);
	 
	/* clean up memory */
	EVP_CIPHER_CTX_cleanup(ctx);
	free(ctx);
	free(enc_buffer);
	free(buffer);
	
	return 0;
}

/* This function receives a file from the server
	1) input file_name = name of the file to be received
	2) input sk = socket used to receive the file
	3) returns 0 in case of success, -1 otherwise */
int recv_file_crypt(const char* file_name, int sk, unsigned char* session_key, int session_key_len ){
	/* Allocation of the context each time we want receive a message */
	EVP_CIPHER_CTX *ctx = malloc(sizeof(EVP_CIPHER_CTX));
	EVP_CIPHER_CTX_init(ctx);
	EVP_DecryptInit(ctx, EVP_des_ecb(), NULL, NULL);
	EVP_DecryptInit(ctx, NULL, session_key, NULL);
	EVP_CIPHER_CTX_set_key_length(ctx, session_key_len);
	int session_bsize = EVP_CIPHER_CTX_block_size(ctx);
    
	
	int err, ret, loutU, loutF;
	int name_size;			/* length of the name of the received file */
	int size;				/* size of the buffer for the plaintext  */
	unsigned char* buffer;		/* plaintext buffer */
	unsigned char* path_file;		/* given by the concatenation of user directory and name of the file */	
	unsigned char* enc_buf;		/* used to decrypt the incoming file */
	unsigned char* buf_res;		/* buffer containing server response */
	FILE* file;				/* pointer to the file where the received message will be saved */
    

	/* the send_message encrypts a message and send it to the server to let it understand what to do */
	char* mex = "down";
	err = send_message((unsigned char*)mex, sk, session_key, session_key_len);
	if(err < 0 ){
		printf("It's not possible to communicate with the server\n");
		return -1;
	}

	/* Computation of the length of the filename */
	name_size = strlen(file_name) + 1;

	/* The length of the file name is sent */
	ret = send(sk, &name_size, sizeof(int), 0); 
	if(ret != sizeof(int)){
		printf("Error transmitting the length of the file name\n ");
		return -1;
	}
    
	/* The file name is sent */
	ret = send(sk, file_name, name_size, 0); 
	if(ret != name_size){
	        printf("Error transmitting the file name\n ");
	        return -1;
	}
	
	/* Allocating memory to know server response */
	buf_res = malloc(sizeof(int));
	
	/* Receiving the response if the file is present or not */
	ret = recv(sk, buf_res, sizeof(int), MSG_WAITALL);
	if(ret != sizeof(int)){
		printf("Error Receiving Response.\n");
		return -1;
	}

	if(*(int*)buf_res == 0){
		free(buf_res);
		printf("File not present in server's directory\n");
		return -1;
		}

	else{
		/* Content of the file encrypted, other values sent in clear  */
	  	printf("Receiving file from the server.\n");
	  
	  
	  	/* Reception of the file size */
	  	ret = recv(sk, &size, sizeof(int), MSG_WAITALL);
	  	if(ret != sizeof(int)) {
	    		printf("Error receiving the file size\n");
	    		return -1;
	  	}
	
	  	/* Memory allocation */
	  	enc_buf = malloc(size);
	  	if(enc_buf == NULL){
	    		printf("Error allocating memory for a file from the server.\n");
	    		return -1;
	 	}
	 
	  	/* Reception of the file */
	  	ret = recv(sk, enc_buf, size, MSG_WAITALL);
	  	if(ret != size) {
	    		printf("Error receiving the file\n");
	    		return -1;
	 	}
	  
	  	/* preparing creation of the file */
	  	path_file = malloc(strlen(path_usr_file) + strlen((char*)file_name) + 1);
	  	strcpy((char*)path_file, path_usr_file);
	  	strcat((char*)path_file, (char*)file_name);
	  
	  	/* decrypting incoming file */
	  	buffer = malloc(size + session_bsize);
	  	EVP_DecryptUpdate(ctx, buffer, &loutU, enc_buf, size);
	  	EVP_DecryptFinal(ctx, &buffer[loutU], &loutF);
	  
	  	/* Open the file to save the received message */
	  	file = fopen((char*)path_file, "wb");
	    	if(file == NULL) {
	     		printf("File not written\n");
	      		return -1;
	  	}
	  
	  	/* Write the received message in the local file */
	  	ret = fwrite(buffer, sizeof(char), (loutU + loutF) , file);
	  	if(ret != (loutU + loutF)) {
	      		printf("Error writing the file.\n");
	      		return -1;
	  	}    
	  
	  	printf("Received file %s with size %d bytes.\n", file_name, loutU + loutF);
	  
	  	fclose(file);
	  	free(path_file);
	  	free(buffer);
	  	free(enc_buf);
	  	free(buf_res);
	      
	  	return 0;
	 }
}

/* Send the name of the file that must be removed 
	1) input file_name = name of the file to be removed
	2) input sk = socket used to receive a response
	3) returns 0 in case of success, -1 otherwise */
int rmv_file(const char* file_name, int sk, unsigned char* session_key, int session_key_len){
	
	int name_size, ret;
	void* buf;

	/* the send_message encrypts a message and send it to the server to let it understand what to do */
	char* mex = "remv";
	ret = send_message((unsigned char*)mex, sk, session_key, session_key_len);
	if(ret < 0 ){
		printf("It's not possible to communicate with the server\n");
		return -1;
	}

	/* Computation of the length of the filename */
	name_size = strlen(file_name) + 1;

	/* The length of the file name is sent */
	ret = send(sk, &name_size, sizeof(int), 0); 
	if(ret != sizeof(int)){
		printf("Error transmitting the length of the file name\n ");
		return -1;
	}
    
	/* The file name is sent */
	ret = send(sk, file_name, name_size, 0); 
	if(ret != name_size){
	        printf("Error transmitting the file name\n ");
	        return -1;
	}

	buf = malloc(sizeof(int));

	ret = recv(sk, buf, sizeof(int), MSG_WAITALL);
	if(ret != sizeof(int)){
	        printf("Error receiving server response\n ");
	        return -1;
	}

	if(*(int*)buf == 0)
		printf("File cannot be removed from the server\n");
	
	else 
		printf("File %s deleted from the server.\n", file_name);

	free(buf);

	return 0;
}

/* the send_message encrypts a message and send it to the server to let it understand what to do */
int send_message(unsigned char* mex, int sk, unsigned char* session_key, int session_key_len){

	unsigned char* buffer;
	int size, ret, loutU, loutF;

	/* it's own context */
	EVP_CIPHER_CTX * ctx = malloc(sizeof(EVP_CIPHER_CTX));
	EVP_CIPHER_CTX_init(ctx);
	EVP_EncryptInit(ctx, EVP_des_ecb(), NULL, NULL);
	EVP_EncryptInit(ctx, NULL, session_key, NULL);
	EVP_CIPHER_CTX_set_key_length(ctx, session_key_len);
	int session_bsize = EVP_CIPHER_CTX_block_size(ctx);

	size = strlen((char*)mex) + 1;
	
	/* now we encrypt it */
	buffer = malloc(session_bsize + size);
	if(buffer == NULL){
		printf("No memory available");
		return -1;
	}
	
	EVP_EncryptUpdate(ctx, buffer, &loutU, mex, size);
	EVP_EncryptFinal(ctx, &buffer[loutU], &loutF);
	size = loutU + loutF;								/* size of the encrypted mex */
	
	ret = send(sk, &size, sizeof(int), 0); 
	if(ret != sizeof(int)){
	    printf("Error transmitting the length of the message\n");
	    return -1;
	}
	
	ret = send(sk, buffer, size, 0); 
	if(ret != size){
	    printf("Error transmitting the message\n");
	    return -1;
	}
	
	EVP_CIPHER_CTX_cleanup(ctx);
	free(ctx);
        free(buffer);

	return 0;
}
